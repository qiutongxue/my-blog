---
title: 代码速查
comments: true
toc: true
toc_number: true
copyright: true
mathjax: false
katex: true
sticky: 0
date: 2021-08-20 16:20:23
tags: ['LeetCode', '数据结构与算法']
category: '计算机相关'
keywords: ['动态规划', '最短路径', '算法']
description: 边想边敲哪有复制粘贴来的方便
top_img:
cover: 'https://markdown-img-1306901910.cos.ap-nanjing.myqcloud.com/创作型ppt.jpg'
---


# 数学

### 最大公约数 GCD

```java
/** 
* 求两个数的最大公约数
* @param a 待求的一个数
* @param b 待求的另一个数，不用在意 a 和 b 的大小关系
* @return a 和 b 的最大公约数
*/
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```



### 最小公倍数 LCM

```java
/** 
* 求两个数的最小公倍数
* @param a 待求的一个数
* @param b 待求的另一个数
* @return a 和 b 的最小公倍数
*/
int lcm(int a, int b) {
    // a x b = gcd(a, b) * lcm(a, b)
    return a * b / gcd(a, b);
}
```



### 快速幂

```java
/**
* 快速幂的递归版本
* @param a 底数
* @param b 幂
* @return a^b 的结果，取 MOD
*/
long fastPow(long a, long b) {
    // int MOD = 1000000007;
    a = a % MOD;
    if (b == 1) return (int) a;
    long result = fastPow(a, b / 2);
    if ((b & 1) == 0) {
        return result * result % MOD;
    }
    return (a * result) % MOD * result % MOD;
}
```



```java
/**
* 快速幂的迭代版本
* @param a 底数
* @param b 幂
* @return a^b 的结果，取 MOD
*/
long fastPow(long a, long b) {
    // int MOD = 1000000007;
    long base = a % MOD, res = 1;
    while (b != 0) {
        if ((b & 1) == 1) {
            res = res * base % MOD;
        }
        base = base * base % MOD;
        b >>>= 1;	
    }
    return res % MOD;
}
```



### 矩阵快速幂

```java
/**
* 矩阵乘法运算 A(m*p) * B(p*n)
*/
int[][] mul(int[][] A, int[][] B) {
    int m = A.length, n = B[0].length, p = B.length;
    int[][] res = new int[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < p; k++) {
                res[i][j] = (int) ((1L * res[i][j] + 1L * A[i][k] * B[k][j]) % MOD);
            }
        }
    }
    return res;
}

/**
* 矩阵快速幂，传入的矩阵必须是方阵，计算 A^b
*/
int[][] matrixFastPow(int[][] A, int b) {
    int n = A.length;
    int[][] mat = new int[n][n], res = new int[n][n];
    // res 初始化为单位矩阵
    for (int i = 0; i < n; i++) {
        res[i][i] = 1;
    }
    // mat 克隆 A
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            mat[i][j] = A[i][j];
        }
    }
    // 代入常规的快速幂中
    while (b != 0) {
        if ((b & 1) == 1) {
            res = mul(res, mat);
        }
        mat = mul(mat, mat);
        b >>>= 1;	
    }
    return res;
}
```

- [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)
-  [552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)



### 蓄水池抽样

**描述**：总样本数为 N，对于遇到的第 $i$ 个样本（$i$ 从 1 开始算），设其被选择的概率为 $\cfrac K i$，最终获得 $K$ 个样本，且满足每个样本被选择的概率为 $\cfrac K N$​。

**应用**：一次遍历即可获得 K 个随机数，一般用于解决未知大小的数据流或数据量很大的情况。

**证明**：前 $K$​​ 个样本放入容量为 $K$​ 的容器中，每个样本都能放入，故概率均为 $p(1) = p(2) = \cdots = p(K) = 1$​​

对于第 $K+1$​​ 个样本，被保留在容器中的概率为 $\cfrac K {K+1}$​​，则需要在容器中随机选择一个样本替换，前 $K$ 个样本被保留的概率即为
$$
p(1) = p(2) = \cdots = p(k) = 1 \times (\cfrac 1 {K+1} + \cfrac K {K+1} \times \cfrac {K-1} K) = \cfrac K {K+1}
$$
对于第 $K+2$​ 个样本，被保留在容器中的概率为 $\cfrac K {K+2}$​，则需要在容器中随机选择一个样本替换，前 $K+1$ 个样本被保留的概率即为
$$
p(1) = p(2) = \cdots = p(k) = p(k+1) = \cfrac K {K+1} \times (\cfrac 2 {K+2} + \cfrac K {K+2} \times \cfrac {K-1} K) = \cfrac K {K+2}
$$
……

不失一般性地，对于第 $i~(i > K)$​​​​ 个样本，其保留概率为 $\cfrac K i$，则前 $i-1$ 个样本 $n_r~(r ∈ (1, i-1))$ 被保留在容量为 $K$​​​​​ 的容器中的概率为
$$
p(n_r) = \cfrac K {i-1} \times (  \cfrac {i-K} i + (\cfrac K i \times \cfrac {K-1} K)) = \cfrac K i
\\
\\
p = p(\text{在 }i-1 \text{ 轮保留下来}) \times \Big( p(\text{样本 }i\text{ 未被选择}) + p(\text{样本 }i\text{ 被选择}) * p(\text{未被样本 } i \text{ 替换})\Big)
$$

当 $i = N$​ 时，即有
$$
p(n_1) = p(n_2) = \cdots = p(n_{N-1}) = p(n_N) = \cfrac K N
$$

```java
/**
* 按照水塘抽样从 nums 数组中随机抽取 k 个数，每个数被抽到的概率相同
* @params nums 待抽取数据
* @params k 抽取的样本数
* @return 返回抽取样本
*/
int[] reservoirSampling(int[] nums, int k) {
    int[] res = new int[k];
    Random r = new Random();
    for (int i = 0; i < k; i++) {
        res[i] = nums[i];
    }
    for (int i = k; i < nums.length; i++) {
        int t = r.nextInt(i+1);
        // 抽到了
        if (t < k) {
            res[t] = nums[i];
        }
    }
    return res;
}
```

[LeetCode 水塘抽样相关题目](https://leetcode-cn.com/tag/reservoir-sampling/problemset/)



### 约瑟夫环

给出 n 个人围成一圈，，编号为 1 ~ n，从编号 1 开始报数，数到 m 的人被淘汰，下一个人从 1 重新报数，求出获胜者。

```java
int solve(int n, int m) {
	int p = 0;	// 获胜者的位置，由于是从后往前倒推，所以初始位置为 0
    for (int i = 2; i <= n; i++) {
        // 求出获胜者在本轮的位置
        p = (p + m) % i;
    }
    // 编号从 1 开始，所以要补上 1
    return p+1;    
}
```

[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)



### 埃式筛法

```java
boolean[] getPrime(int maxNumber) {
    boolean[] isNotPrime = new boolean[maxNumber + 1];
    // 埃式筛法
    for (int i = 2; i < Math.sqrt(maxNumber); i++){ 
        if (!isNotPrime[i]) { // 如果是质数，筛掉质数的倍数
            for (int j = i*i; j <= maxNumber; j+=i){ // 筛掉i的倍数（1~i-1倍已经在前面筛过了，所以不用考虑）	
                isNotPrime[j] = true;  // j必不是质数
            }
        }
    } 
    return isNotPrime;
}	
```



### 组合（+乘法逆元）

我们知道计算组合数的公式：
$$
C_n^k = \cfrac {n!} {k!(n-k)!} 
$$

在数很大的情况下需要取模 $MOD = 1e9 + 7$ ，而取模的操作只包含了 `+ - *`，并不能使用 `/`，故需要用到乘法逆元。

**乘法逆元**：
$$
\cfrac b a \equiv b \cdot a^{-1} ~(mod ~m)
$$
即在取模运算中，只要找到一个数 $q$，使 $ a \cdot q \equiv 1 ~(mod ~m)$ ，则有 $\cfrac b a \equiv b \cdot q ~(mod ~m)$ 。计算乘法逆元需要用到费马小定理

**费马小定理**：若 $p$ 是质数，且 $a ~mod~ p \ne 0$， 则有 
$$
a ^  {p-1} \equiv 1 ~ (mod ~p)
$$

$$
\begin{align*}
a ^ {m-1} &\equiv 1 ~(mod ~m) \\
\lrArr a^{m-1} a^{-1} &\equiv a ^{-1} ~(mod ~m) \\
\lrArr a^{m-2} aa^{-1} &\equiv a^{-1} ~(mod ~m) \\
\lrArr a^{-1} &\equiv a ^{m-2} ~(mod ~m)
\end{align*}
$$

故只需要计算 $a ^{m-2}$  即可（用快速幂）



```java
static int size = 100000; /
static int MOD = (int) 1e9 + 7;
static long[] fac, inv; // fac[i] 为 i!，inv[i] 表示 fac[i] 的乘法逆元
// 初始化，计算 fac 和 inv
static void initialize(int size) {
    fac = new long[size + 1]; inv = new long[size + 1];
    fac[0] = inv[0] = 1;
    for (int i = 1; i <= size; i++) {
        fac[i] = fac[i-1] * i % MOD;
        // 快速幂计算乘法逆元
        inv[i] = fastPow(fac[i], MOD - 2);
    }
}

// 计算 C(n, k)
long comb(int n, int k) {
    // n! / (k! * (n-k)!)
    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;
}

static long fastPow(long a, long b) {
    // int MOD = 1000000007;
    long base = a % MOD, res = 1;
    while (b != 0) {
        if ((b & 1) == 1) {
            res = res * base % MOD;
        }
        base = base * base % MOD;
        b >>>= 1;	
    }
    return res % MOD;
}
```

[1830. 使字符串有序的最少操作次数](https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-string-sorted/)



# 数据结构

### 线段树

具体问题具体分析，这里默认使用区间赋值操作，如果要用区间增值，把特定位置的 `=` 改成 `+=` 即可

```java
class SegmentTree {
    private int[] tree, nums, lazy;
    public SegmentTree(int[] nums) {
        int n = nums.length;
        tree = new int[4*n];
        lazy = new int[4*n];    // lazy tag
        this.nums = nums;
        buildTree(0, 0, n-1);
    }

    /**
    * 构建线段树
    * @param node 当前节点对应到 tree 的下标
    * @param start 当前节点对应的 nums 区间起点
    * @param end 当前节点对应的 nums 区间终点
    */
    private void buildTree(int node, int start, int end) {
        if (start == end) {
            tree[node] = nums[start];
            return;
        }
        int mid = start + (end - start) / 2;
        int leftNode  = node * 2 + 1;
        int rightNode = node * 2 + 2;

        buildTree(leftNode, start, mid);
        buildTree(rightNode, mid+1, end);

        tree[node] = tree[leftNode] + tree[rightNode];
    }

    private void pushDown(int node, int start, int end) {
        if (lazy[node] == 0) {
            return;
        }
        int leftNode = node * 2 + 1;
        int rightNode = node * 2 + 2;
        int mid = start + (end - start) / 2;
        
    	// 如果方案为区间增值，把下面四个 = 改成 += 即可
        tree[leftNode] = lazy[node] * (mid - start + 1);
        lazy[leftNode] = lazy[node];
        tree[rightNode] = lazy[node] * (end - mid);
        lazy[rightNode] = lazy[node];
        // 清空当前 lazy tag
        lazy[node] = 0;
    }
    
    /**
    * 更新线段树
    * @param node 当前节点对应到 tree 的下标
    * @param start 当前节点对应的 nums 区间起点
    * @param end 当前节点对应的 nums 区间终点
    * @param left 待更新的 nums 左端点
    * @param right 待更新的 nums 右端点
    * @param val 区间设定的值
    */
    private void updateTree(int node, int start, int end, int left, int right, int val) {
        // 当前节点被区间完全覆盖，更新节点并设置 lazy tag，这样就没必要向下更新了
        if (left <= start && end <= right) {
            // 如果方案为区间增值，把下面两个 = 改成 += 即可
            tree[node] = (end - start + 1) * val;  
            lazy[node] = val;   
            return;
        }

        // 把当前节点的 lazy tag 传递到下一层
        pushDown(node, start, end);

        int mid = start + (end - start) / 2;
        int leftNode = 2 * node + 1;
        int rightNode = 2 * node + 2;

        // 需要更新左子树
        if (left <= mid) {
            updateTree(leftNode, start, mid, left, right, val);
        } 
        // 需要更新右子树
        if (right > mid) {
            updateTree(rightNode, mid+1, end, left, right, val);
        } 
        // 更新当前节点
        tree[node] = tree[leftNode] + tree[rightNode];
    }

    /** 
    * 查询线段树
    * @param node 当前节点对应到 tree 的下标
    * @param start 当前节点对应的 nums 区间起点
    * @param end 当前节点对应的 nums 区间终点
    * @param left 待查询的 nums 区间起点
    * @param right 待查询的 nums 区间终点
    */
    private int queryTree(int node, int start, int end, int left, int right) {
        // 查找范围不在当前范围内
        if (right < start || left > end) {
            return 0;
        }
        // 当前范围就在查找范围中，直接返回
        if (start >= left && end <= right) {
            return tree[node];
        }
        
        // 部分范围在查找区间中，先把 lazy tag 传下去
        pushDown(node, start, end);

        int mid = start + (end - start) / 2;
        int leftNode = 2 * node + 1;
        int rightNode = 2 * node + 2;
        int leftSum = queryTree(leftNode, start, mid, left, right);
        int rightSum = queryTree(rightNode, mid+1, end, left, right);
        return leftSum + rightSum;
    }

    /**
    * 更新 nums 下标的值
    * @param index 对应的 nums 下标
    * @param val 更新的值
    */
    public void update(int index, int val) {
        updateTree(0, 0, nums.length-1, index, index, val);	
    }

    /**
     * 区间更改
     * @param left nums 左端点
     * @param right nums 右端点
     * @param val 设定的值
     */
    public void update(int left, int right, int val) {
        updateTree(0, 0, nums.length - 1, left, right, val);
    }
    
    /**
    * 查询 nums 的区间和
    * @param left 区间起点
    * @param right 区间终点
    */
    public int query(int left, int right) {
        return queryTree(0, 0, nums.length-1, left, right);
    }
}
    
// 307. 区域和检索 - 数组可修改 https://leetcode-cn.com/problems/range-sum-query-mutable/
```



### 树状数组

![img](https://markdown-img-1306901910.cos.ap-nanjing.myqcloud.com/20200717113236761.png)

```java
class BinaryIndexedTree {
    int[] tree, nums;
    int n;
    public BinaryIndexedTree(int[] nums) {
        n = nums.length;
        this.nums = nums;
        // tree 下标以 1 开始
        tree = new int[n+1];
        for (int i = 0; i < n; i++) {
            add(i, nums[i]);
        }
    }

    /**
    * 在指定下标增加值
    * @param idx 指定数组下标
    * @param val 要增加的值（不是修改，是增加）
    */
    private void add(int idx, int val) {
        for (int i = idx + 1; i <= n; i += lowbit(i)) {
            tree[i] += val;
        }
    }

    /**
    * 更新指定下标的值
    * @param idx 指定数组下标
    * @param val 要更新的值
    */
    public void update(int idx, int val) {
        add(idx, val - nums[idx]);
        nums[idx] = val;
    }

    /**
    * 查找前缀和
    * @param idx 查询的右端点
    * @return nums[0:idx] 的和
    */
    public int query(int idx) {
        int res = 0;
        for (int i = idx + 1; i > 0; i-= lowbit(i)) {
            res += tree[i];
        }
        return res;
    }
    
    /**
    * 查找区间和
    * @param left 左端点
    * @param right 右端点
    */
    public int query(int left, int right) {
        return query(right) - query(left - 1);
    }

    private int lowbit(int x) {
        return x & -x;
    }
}
```





### 0/1 字典树

```java
class Trie {
    class TrieNode {
        TrieNode[] son = new TrieNode[2];
        int[] cnt = new int[2];	// 统计子结点路径数，离线删除
    }
    
    TrieNode root;
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(int val) {
        insertAndDelete(val, 1);
    }
    
    public void delete(int val) {
        insertAndDelete(val, -1);
    }
    
    /**
    * 在树中插入/删除一个数
    * @param val 待插入/删除的数
    * @param s 标记符号，1 表示插入，-1 表示删除
    * @return null
    */
    private void insertAndDelete(int val, int s) {
        TrieNode node = root;
        for (int i = 30; i >= 0; i--) {
            int v = ((1 << i) & val) >>> i;
            if (node.son[v] == null) {
                node.son[v] = new TrieNode();
            }
            node.cnt[v] += s;
            node = node.son[v];
        }
    }
    
    /**
    * 找到树中与 val 异或的最大值
    * @param val 需要异或的 val
    * @return 返回最大异或结果
    */
    public int getXorMax(int val) {
        TrieNode node = root;
        int res = 0;
        for (int i = 30; i >= 0; i--) {
            int v = ((1 << i) & val) >> i;
            // 找异或最大，优先找反方向
            if (node.cnt[v^1] > 0) {
            	// 有反方向的数，该位的结果为 1
                res |= 1 << i;
                node = node.son[v^1];
            } else if (node.cnt[v] > 0) {
                node = node.son[v];
            } else {
                return -1;
            }
        }
        return res;
    }
}
```



### 并查集

```java
class UnionFind {
    int[] parent, size;
    public UnionFind(int n) {
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    /**
    * 合并两个节点所在的集合
    * @param x 待合并的一个节点
    * @param y 待合并的另一个节点
    * @return null
    */
    public void union(int x, int y) {
        int rootX = find(x), rootY = find(y);
        if (rootX == rootY) { // 在同一个集合中
            return;
        }
        if (size[rootX] > size[rootY]) { // 按秩合并，优化时间
            int t = rootX;
            rootX = rootY;
            rootY = t;
        }
        parent[rootX] = rootY;
        size[rootY] += size[rootX];
    }
    
    
    public boolean isUnion(int x, int y) {
        return find(x) == find(y);
    }
    
    /**
    * 查找根节点
    * @param x 待查找的节点
    * @return 返回根节点
    */
    private int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  	 // 路径压缩
        }
        return parent[x];
    }
}
```



### 跳表 Skiplist

```java
class Skiplist {
    // P 和 MAX_LEVEL 取值参考自 Redis
    private static int MAX_LEVEL = 32;  // 允许的最大层数
    private static double P = 0.25;     // 生成 level 层的概率为 P^(level-1)

    class SkiplistNode {
        int val;
        SkiplistNode[] next;
        public SkiplistNode(int val, int level) {
            this.val = val;
            next = new SkiplistNode[level];
        }
    }

    private int level = 1;              // 当前跳表中的最大层数
    private SkiplistNode head;
    public Skiplist() {
        head = new SkiplistNode(-1, MAX_LEVEL);
    }
    
    public boolean search(int target) {
        SkiplistNode prev = head;
        for (int i = level - 1; i >= 0; i--) {
            prev = findNodeOnLevel(prev, target, i);
            if (prev.next[i] != null && prev.next[i].val == target) {
                return true;
            }
        }
        return false;
    }
    
    public void add(int num) {
        int level = getRandomLevel();
        SkiplistNode newNode = new SkiplistNode(num, level);
        SkiplistNode prev = head;
        this.level = Math.max(this.level, level);
        for (int i = this.level - 1; i >= 0; i--) {
            // 这个位置很重要
            prev = findNodeOnLevel(prev, num, i);
            if (i < level) {
                newNode.next[i] = prev.next[i];
                prev.next[i] = newNode;
            }
        }
    }
    
    public boolean erase(int num) {
        SkiplistNode prev = head;
        boolean f = false;
        for (int i = level - 1; i >= 0; i--) {
            prev = findNodeOnLevel(prev, num, i);
            if (prev.next[i] != null && prev.next[i].val == num) {
                f = true;
                prev.next[i] = prev.next[i].next[i];
            }
        }
        return f;
    }

    /**
    * 获得随机层数
    * @return 返回层数
    */
    private int getRandomLevel() {
        int level = 1;
        while (Math.random() < P && level < MAX_LEVEL) {
            level++;
        }
        return level;
    }

    /**
    * 在指定层数查找目标值对应的节点位置
    * @param node 起始的查找节点
    * @param target 目标值
    * @param level 指定层数
    * @return 返回的 node.next[level] 即为目标节点的位置
    */
    private SkiplistNode findNodeOnLevel(SkiplistNode node, int target, int level) {
        while (node.next[level] != null && node.next[level].val < target) {
            node = node.next[level];
        }
        return node;
    }
}
```



# 算法

### 快速排序

因为 [面试题 17.14. 最小K个数](https://leetcode-cn.com/problems/smallest-k-lcci/) 总是在边界处理的时候遇到问题，故记录一下，标准的快排是咋做的

```java
void quickSort(int[] arr, int l, int r) {
	// 先确定主元，可以用 random，也可以直接用最左边的
    // int randIdx = new Random().nextInt(r - l + 1) + l;
    // swap(arr, randIdx, l);
    // 这里直接用最左边的当主元了，注意！！！ i 从 l 开始，不要从 l + 1 开始
    if (l >= r) return;
    int i = l, j = r;
    int pivot = arr[l];
    while (i < j) {
        // ※ 先移动右边的指针 ※ 要用到【=】号
        while (i < j && arr[j] >= pivot) j--;
        while (i < j && arr[i] <= pivot) i++;
        swap(arr, i, j);
    }
    // ※ 交换 i 和 l，此时 i 就是主元的正确位置
    swap(arr, i, l);
    
    /* 如果是做 最小 K 个数的话，就按照 k 来选择排序哪一半
    if (i == k) return;
    else if (i > k) quickSort(arr, l, i - 1);
    else quickSort(arr, i + 1, r);
    */
    
    /* 如果是标准快排，左右直接排序
    quickSort(arr, l, i - 1);
    quickSort(arr, i + 1, r);
    */
}
```



### 回文串预处理

```java
/** 
* 区间 DP 预处理字符串，判断各子串是否是回文串
* @param s 待处理的字符串
* @return [i][j] 表示 s[i:j] 是否是回文串
*/
boolean[][] preHandlePalidrome(String s) {
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    for (int i = 0; i < n; i++) {
        Arrays.fill(dp[i], true);
    }
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i + len - 1 < n; i++) {
            int j = i + len - 1;
            dp[i][j] = dp[i+1][j-1] && s.charAt(i) == s.charAt(j);
        }
    }
    return dp;
}
```



### Morris 遍历

```java
while (root != null) {
    if (root.left != null) {
        TreeNode predecessor = root.left;
        // 找到 root 左子树的最右节点
        while (predecessor.right != null && predecessor.right != root) {
            predecessor = predecessor.right;
        }
        // 第一次遍历到，将 predecessor.right 设为 root
        // 目的是方便最后遍历完回到 root
        if (predecessor.right == null) {
            predecessor.right = root;
            /* 前序遍历位置 */
            // 进入左子树
            root = root.left;
            continue;
        } 
        // 第二次遍历到 predecessor.right == root，说明左子树已经全部遍历完了，可以进入右子树
        // 先恢复 predecessor.right
        predecessor.right = null;
    }
    /* 中序遍历位置 */
    // 进入右子树
    root = root.right;
}
```

[99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)



### 图

#### Dijkstra 单源最短路径

```java
int[] dijkstra(List<Integer>[] graph, int src) {
    int n = graph.length;
    PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]){{ offer(src); }};
    int[] dist = new int[n];
//    int[] path = new int[n];
	Arrays.fill(dist, INF);
//    Arrays.fill(path, -1);
   	dist[src] = 0;
    boolean[] vis = new boolean[n];
    while (!pq.isEmpty()) {
        int cur = pq.poll()[0];
        if (vis[cur]) continue;
        vis[cur] = true;
        for (int nxt : graph[cur]) {
            if (!vis[nxt] && dist[cur] + graph[cur][nxt] < dist[nxt]) {
                dist[nxt] = dist[cur];
//                path[nxt] = cur;
                pq.offer(new int[]{nxt, dist[nxt]});
            }
        }
    }
    return dist;
//    return path;
}
```



#### Floyd 多源最短路径

```java
int[][] floyd(int[][] graph) {
    int n = graph.length;
    int[][] dist = new int[n][n];
//    int[][] path = new int[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = graph[i][j];
//            path[i][j] = -1;
        }
    }
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            if (graph[i][k] == INF) continue;
            for (int j = 0; j < n; j++) {
                if (dist[i][k] + dist[k][j] <= dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
//                    path[i][j] = k;
                }
            }
        }
    }
    return dist;
//    return path;
}
```



#### 拓扑排序

```java
boolean topSort(List<Integer>[] graph) {
    int n = graph.length;
    int[] indegree = new int[n];
    for (int i = 0; i < graph.length; i++) {
        for (int j : graph[i]) {
            indegree[j]++;
        }
    }
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < n; i++) {
        if (indegree[i] == 0) {
            q.offer(i);
        }
    }
    List<Integer> topOrder = new ArrayList<>();
    while (!q.isEmpty()) {
        int cur = q.poll();
        topOrder.add(cur);
        for (int nxt : graph[cur]) {
            /* do something... */
            if (--indegree[nxt] == 0) {
                q.offer(nxt);
            }
        }
    }
    // 检查是否有环
    return topOrder.size() == n;
}
```



#### Prim 最小生成树



#### Kruskal 最小生成树



#### A*寻路

```java
PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) -> o1.F - o2.F);
int[] dist; // dist[i] 表示 i 到 src 的距离
int[] comeFrom; // comeFrom[i] 表示 i 的上一个节点

while (!pq.isEmpty()){
    Node cur = pq.poll();
    if (cur.id == target) {
        break;
    }
    for (int next : cur 的所有邻居) {
        int newCost = dist[cur] + graph[cur][next];
        if (neighbor 未访问过 || newCost < dist[next])  {
            int f = newCost + getH(next, target);
 			pq.offer(new Node(next, f));
            comeFrom[next] = cur.id;
        }
    }
}

List<Integer> path = new ArraytList<>();
for (int cur = target; cur != -1; cur = comeFrom[cur]) {
    path.add(cur);
}
path.reverse();
```





### KMP

```java
/**
* 使用 KMP 查找字符串位置
* @param s 原串
* @param p 匹配串
* @return s 在 p 中出现的第一个位置
*/
public int strStr(String s, String p) {
    if (p.length() == 0) return 0;
    /* KMP 算法，O(m+n) */
    // KMP 算法就是利用匹配串的相同前后缀长度，来减少原串的重复匹配过程
    // 最为核心的部分是 next 数组

    // 获得模式串的 next 数组
    int[] next = getNext(p);
    // i 为 s 的指针，j 为 p 的指针
    for (int i = 0, j = 0; i < s.length(); i++) {
        while (j > 0 && s.charAt(i) != p.charAt(j)) {
            // 不相同，找到 s 和 p 之前匹配过得相同的部分
            // 此时 p[0 : j-1] 和 s[i-j : i-1] 是匹配的
            // 所以 p 的前缀 [0 : next[j-1]] 和 s 的后缀 [i-1-next[j-1]:i-1] 是匹配的          
            j = next[j-1];
        }
        if (s.charAt(i) == p.charAt(j) && ++j == p.length()) {
            return i-j+1;
            // j = next[j-1]; // 若要查询所有的位置，j 要变
        }
    }
    return -1;
}

/** 
* 构建 next 数组，此乃 KMP 的核心内容
*/
public int[] getNext(String s) {
    int[] next = new int[s.length()];
    // i 为前缀字符串的结尾指针，j 为后缀字符串的结尾指针
    for (int i = 0, j = 1; j < s.length(); j++) {
        // 相同的前后缀不匹配！，找到之前匹配过的前缀
        while(i > 0 && s.charAt(i) != s.charAt(j)) {
            // next[i-1] 记录了 s[0 : i-1] 的最长相同前后缀长度
            // 因为也是前缀长度，所以 i 直接定位到 next[i-1]
            // 此时前缀 s[0 : i-1] 和后缀 s[j-i : j-1] 仍相同
            i = next[i-1];
        }
        
        // 此时若 s[i] == s[j]，说明了最长相同前后缀的长度就是 len(s[0:i]) = i+1;
        // 若 s[i] != s[j]，说明连第一个字母都不匹配，i 仍为 0
        if (s.charAt(i) == s.charAt(j)) {
            i++;
        }
        next[j] = i;
    }
    return next;
}
```



# 工具

### I/O

```java
import java.io.*;

...() throws IOException

BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));

reader.readLine();	// 读一行
reader.close();

writer.write("");	// 写
writer.flush();		// 把缓冲区的字符刷新到屏幕
writer.close(); 	// 关闭
```





# 动态规划分类

**将数组划分为 k 个区间，使【区间和】最小。**

- [1335. 工作计划的最低难度](https://leetcode-cn.com/problems/minimum-difficulty-of-a-job-schedule/)
- [1959. K 次调整数组大小浪费的最小总空间](https://leetcode-cn.com/problems/minimum-total-space-wasted-with-k-resizing-operations/)

**背包问题**

- 01背包
- 完全背包

> 如何界定 01 背包还是完全背包
>
> 看触及的次数，次数少的放外循环，次数多的放内循环。
>
> 如：01 背包，每个物品最多只能选择一次，故物品的遍历放在外循环，背包的容量放在内循环。而完全背包，每个物品能选择多次，那么物品遍历放内循环，背包容量遍历放外循环。

**状态DP**

状态 DP 一般用来解决子集遍历的问题。

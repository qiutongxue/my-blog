---
title: '基于8051单片机的16×16点阵屏滚动显示'
comments: true
toc: true
toc_number: true
copyright: true
mathjax: false
katex: true
sticky: 0
date: 2020-09-09 13:29:47
tags: ['单片机', 'ASM']
category: '计算机相关'
keywords:
description: 两年前微机课的大作业，使用汇编语言编写
top_img:
cover: 'https://gitee.com/qiutongxue/blog-images/raw/master/img/20200909175629.jpg'
---

## 写在前面

今天也是闲来无事（当然这几个月都很闲），蹲坑时看到了莱茵生命和 Arduino 相似之处，突然就想到了之前上微机课时的大作业。想着这博客文章也太少了，不如就拿这个再水一篇哈哈哈。

但是！当我去翻文件的时候才知道事情并不简单。我的手里有 PPT、源码和 PDF 版的实验报告，没有视频，没有原图，更关键的是，现在再去看这一堆忘得差不多的汇编源码，我脑壳有点晕。

## 原理

这个作业用的是学校发的 8051 开发板，上面集成了各种套件，只要按引脚插线就完事了，所以关键在于怎么个插线法。

首先要知道我们用了哪些套件：

- 单片机
- 点阵屏
- 蜂鸣器（各功能的声音回馈）
- 按钮

似乎就这些了哈，然后重点说一下点阵屏这块。

### 点阵屏

对于一个 16x16 点阵屏，需要对应 16+16=32 个输入信号，显然仅凭单片机的引脚一对一输出是不可能的，这里就需要 **74HC595 移位寄存器**了（通俗点来说，就是串行出入，并行输出）。

![74HC595原理图](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200909140224.png)

在单片机开发板上有3个可以输入的端口：

- SRCLK（11）：上升沿时数据寄存器的数据移位。Q0->Q1->Q2-->Q3-->...-->Q7;下降沿移位寄存器数据不变。
- RCLK（12）：上升沿时移位寄存器的数据进入数据存储寄存器，下降沿时存储寄存器数据不变。
- SER（14）：串行输入端，数据由P3.4输入。

输出的话就是 `QA~QH` 为并行输出，`QH'` 为级联输出。

![8051开发板连线](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200909141157.png)

上图是开发板内部 16×16 点阵和 74HC595 的连线示意图。`NEG1~NEG16` 和 `POS1~POS16` 就是点阵的那 32 个输入点，从图上可以看到，`NEG1~NEG16` 已经在内部与第三、四块 74HC595 接好了，同时也注意到，这四块 74HC595 依靠其各自的 `QH'` 级联在一起，意味着它们可以**同时输出 8×4=32 位（即 4 字节）信号**。假设由 P3.4 依次输入了 4 个字节的数据，第一个字节输出到`NEG16-9`，第二个字节输出到 `NEG8-1`，第三个字节输出到 `POS16-9`，第四个字节输出到 `POS8-1`。

`P595 A` 和 `P595 B` 是第一、二块 74HC595 暴露的输出引脚，`J18` 和 `J17` 是点阵屏暴露的输入引脚。这下就很容易了，只要把这几个引脚按照图示像第三、四块 74HC595 那样接好就行了。

现在我们知道了，接好线之后，每四个字节的数据就会产生 32 个 0/1 信号输入到点阵屏中，那么现在的问题是，点阵屏是如何照这些信号显示相应的图形的呢？先看原理图。

![16x16点阵原理图](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200909142012.png)

看了原理图就明白了吧，16×16 点阵屏由 256 个发光二极管组成，NEG 信号控制各列的发光二极管，POS 信号控制各行的发光二极管。如果在图上建立一个坐标系，以左上角为原点，NEG1 -> NEG16 为 x 轴正方向， POS1 -> POS16 为 y 轴正方向，可以得出一个结论：

$$
NEGx = 0 \text{且} POSy = 1 \Leftrightarrow (x, y) \text{处的灯亮}
$$

但是只是这样就搞定了吗？不是的，你可以尝试一下怎么只让对角线上的灯发光？照着上面的公式，似乎可以解决：让 `NEG1~16 = 0` 且 `POS1~16 = 1`。这样可就掉坑里了，因为所有灯都会亮。

这就要引入一个新的点——动态扫描。

什么是动态扫描呢？就是从左到右依次点亮每一列，不断循环。因为频率超出人眼所能识别范围，所呈现出的图像在人眼看来是完整的。

好，现在可以尝试一下怎么让对角线上等发光了：先让 `NEG1 = 0，NEG2~16 = 1`，`POS1 = 1, POS2~16 = 0`，这样点亮了 (1,1) 处的灯，然后再使 `NEG2 = 0`，其余 NEG 为 1，`POS2 = 1`，其余 `POS` 为 0……以此类推。

![字模提取工具](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200909150436.png)

如上图所示，借助字模提取工具，我们可以很轻松地提取到想要的字对应的十六进制码。字模将该点阵拆分成了上下两半部分，【点阵生成区】中第一行是上半部分，第二行是下半部分，每个字节从左到右对应每个部分的相应列（8 格）。

{% note info %}
注意：因为接线的不同，各字节对应的行、列控制也不同，需要具体硬件具体分析，比如这里的字模提取工具与作业中实际使用的是有出入的，经过了调试。
{% endnote %}

怎么动起来？

我们可以把要显示的内容拼接成一个长串，然后就像动图那样，每一个完整的扫描过后将内容左移一列，以此类推（类似于滑动窗口）。

![动图思路动图](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200909154040.gif)

### 蜂鸣器

蜂鸣器太简单了，有电就叫，没电就不叫，时间关系就不在这细说了。

### 按钮

按钮也很容易，先鸽着。

## 汇编代码

代码部分看注释就好，感觉还是挺容易实现的。不过因为对中断太陌生了，我使用了一个非常弱智的无限循环方法来实现暂停和复位，并没有用中断来实现，所以整体来开似乎并不太规范。

```asm
ORG 0000H

AJMP MAIN

SER BIT P3.4	;【串行输入】
RCLK BIT P3.5	;【存储时钟】
SRCLK BIT P3.6	;【移位时钟】
K1 BIT P2.0		;【开始/继续】
K2 BIT P2.1		;【暂停】
K3 BIT P2.3		;【复位】
BEEP BIT P1.5	;【蜂鸣器】

ORG 0030H
;**********************4*HC595级联，输送数据****************************  
HC595_OUTPUT:
SETB SRCLK
SETB RCLK
MOV R4,#32
;===============第一位595=================
MOV DPTR,#COL_CONTROL			;先列控
CLR A
MOV A,R2
ADD A,#16
MOVC A,@A+DPTR
CPL A
LOOP1:				       ;---------------------------------	
MOV C,ACC.7				   ;LOOP1~3作用：将数据从高位至				
MOV SER,C				   ;			 低位依次传输到				
RL A 					   ;			 SER中（SER为串			
CLR SRCLK				   ;			 行输入口）,并在
NOP						   ;			 四个级联595中
SETB SRCLK				   ;			 移位。
DEC R4					   ;---------------------------------
CJNE R4,#24,LOOP1								
;==============第二位 595================
CLR A
MOV A,R2
MOVC A,@A+DPTR
CPL A
LOOP2:
MOV C,ACC.7
MOV SER,C
RL A 
CLR SRCLK
NOP
SETB SRCLK 
DEC R4
CJNE R4,#16,LOOP2
;==============第三位595===============
CLR A
MOV DPTR,#ROW_CONTROL2			 ;然后行控（下半屏）
MOV A,R2
ADD A,R1
MOVC A,@A+DPTR
LOOP3:
MOV C,ACC.7
MOV SER,C
RL A 
CLR SRCLK
NOP
SETB SRCLK
DEC R4
CJNE R4,#8,LOOP3
;=============第四位595================
CLR A
MOV DPTR,#ROW_CONTROL1			 ;行控（上半屏）
MOV A,R2
ADD A,R1
MOVC A,@A+DPTR
LOOP4:
MOV C,ACC.7
MOV SER,C
RL A 
CLR SRCLK
NOP
SETB SRCLK
DEC R4
CJNE R4,#0,LOOP4
;=======开始输出/点亮（RCLK上升沿）=====
CLR RCLK
NOP
SETB RCLK
RET
;******************HC595_OUTPUT结束**********************

;*********************延时程序100us*************************
DELAY0:MOV R6,#50
DEL1:DJNZ R6,DEL1
RET

;********************延时程序100ms**********************
DELAY1: MOV R5,#100
DL3:MOV R6,#50
DL4: MOV R7,#10
DJNZ R7,$
DJNZ R6,DL4
DJNZ R5,DL3
RET
;*******************蜂鸣器***************************
BEEP_0: SETB BEEP
LCALL DELAY0
CLR BEEP  
LCALL DELAY0
RET

BEEP_X:						 ;短
MOV 20H,#0FFH
BEEP_1:
LCALL BEEP_0
DJNZ 20H,BEEP_1
RET
BEEP_LONG: MOV 22H,#50		 ;长
		   MOV 21H,#10
BEEP_LONG1:
		   ACALL BEEP_0
		   DJNZ 21H,BEEP_LONG1
		   MOV 21H,#50
		   DJNZ 22H,BEEP_LONG1
		   RET


;***********************主程序*************************

BEEP_B_MAIN:	   ;【复位】提示音，长滴~~~(╯‵□′)╯︵┻━┻
ACALL BEEP_LONG
MAIN:			   ;
CLR BEEP
JNB K1,BEEPx2
AJMP MAIN
BEEPx2:			   ;------------------
LCALL BEEP_X	   ;【开始】提示音	 
LCALL DELAY1	   ;	  滴两声	 
LCALL BEEP_X	   ;------------------
NOP
CMAIN:			   ;CMAIN：我才是真正的主程序
MOV R2,#0	
MOV R1,#0
TOP:
MOV R3,#10	 	;控制每帧占用的时间
MOV R5,#10		;同上
MOV R0,#0		;R0用来判断是否在【暂停】中，R0=1为暂停，R0=0为没暂停
LOOP: 
LCALL HC595_OUTPUT
LCALL DELAY0
INC R2
JNB K3,BEEP_B_MAIN		    ;判断是否有按下【复位】
CJNE R2,#16,LOOP
AJMP JUDGE
BEEP_BEFORE_INFINITY:	  	;------------------------
ACALL DELAY1				;【暂停】提示音，滴一声	丨
LCALL BEEP_X				;------------------------
INFINITY:	   			
MOV R0,#1				;-------------------------
MOV R2,#0				;无限循环实现暂停功能
JNB K1,BEEP_B_LOOP5		;按下【继续】程序继续运行
AJMP LOOP				;-------------------------
JUDGE:					   
JNB K2,BEEP_BEFORE_INFINITY				;----------------------------
CJNE R0,#0,INFINITY						;判断是否有按下【暂停】
AJMP LOOP5								;----------------------------
BEEP_B_LOOP5:		   
MOV R5,#10			   ;------------------------
LCALL BEEP_X		   ;【继续】提示音，滴一声
AJMP LOOP5			   ;------------------------
LOOP5:
MOV R0,#0				;---------------------------------
MOV R2,#0		 		;LOOP5作用：
DJNZ R3,LOOP			; 			循环本轮的扫描，
MOV R3,#2		 		; 			使图像能保持显示。
DJNZ R5,LOOP5	 		;---------------------------------
INC R1
CJNE R1,#80,TOP	        ;进入下一帧显示
AJMP CMAIN				;重复
;******************************************************


;=================行控，屏幕上半段：【*空*】 【I】 【*符号：心*】 【川】 【大】 【*空*】==================
ROW_CONTROL1: DB 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0xFE,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFE,0xFC,0xFC,0xFE,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xFF,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
;=================行控，屏幕下半段：【*空*】 【I】 【*符号：心*】 【川】 【大】 【*空*】==================
ROW_CONTROL2: DB 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x7F,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF,0xFF,0x7F,0x3F,0x1F,0x0F,0x07,0x03,0x01,0x80,0x40,0x30,0x0F,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x80,0x80,0x40,0x20,0x10,0x0C,0x03,0x00,0x03,0x0C,0x10,0x20,0x40,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00   
;====================================列控，从左到右依次扫描（点亮）=======================================
COL_CONTROL: DB 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80


END

```

## 实际效果

只有图片啦，实际上是滚动播放的，并且还会有蜂鸣器的声音。

![实际效果图](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200909132956.png)


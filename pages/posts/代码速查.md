---
title: 代码速查
comments: true
toc: true
toc_number: true
copyright: true
mathjax: false
katex: true
sticky: 0
date: 2021-08-20 16:20:23
tags: ['LeetCode', '数据结构与算法']
category: 工具
keywords: ['动态规划', '最短路径', '算法']
description: 边想边敲哪有复制粘贴来的方便
top_img:
cover: 'https://markdown-img-1306901910.cos.ap-nanjing.myqcloud.com/创作型ppt.jpg'
---
[toc]





# 数学

### 最大公约数 GCD

```java
/** 
* 求两个数的最大公约数
* @param a 待求的一个数
* @param b 待求的另一个数，不用在意 a 和 b 的大小关系
* @return a 和 b 的最大公约数
*/
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```



### 最小公倍数 LCM

```java
/** 
* 求两个数的最小公倍数
* @param a 待求的一个数
* @param b 待求的另一个数
* @return a 和 b 的最小公倍数
*/
int lcm(int a, int b) {
    // a x b = gcd(a, b) * lcm(a, b)
    return a * b / gcd(a, b);
}
```



### 快速幂

```java
/**
* 快速幂的递归版本
* @param a 底数
* @param b 幂
* @return a^b 的结果，取 MOD
*/
long fastPow(long a, long b) {
    // int MOD = 1000000007;
    a = a % MOD;
    if (b == 1) return (int) a;
    long result = fastPow(a, b / 2);
    if ((b & 1) == 0) {
        return result * result % MOD;
    }
    return (a * result) % MOD * result % MOD;
}
```



```java
/**
* 快速幂的迭代版本
* @param a 底数
* @param b 幂
* @return a^b 的结果，取 MOD
*/
long fastPow(long a, long b) {
    // int MOD = 1000000007;
    long base = a % MOD, res = 1;
    while (b != 0) {
        if ((b & 1) == 1) {
            res = res * base % MOD;
        }
        base = base * base % MOD;
        b >>>= 1;	
    }
    return res % MOD;
}
```



### 矩阵快速幂

```java
/**
* 矩阵乘法运算 A(m*p) * B(p*n)
*/
int[][] mul(int[][] A, int[][] B) {
    int m = A.length, n = B[0].length, p = B.length;
    int[][] res = new int[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < p; k++) {
                res[i][j] = (int) ((1L * res[i][j] + 1L * A[i][k] * B[k][j]) % MOD);
            }
        }
    }
    return res;
}

/**
* 矩阵快速幂，传入的矩阵必须是方阵，计算 A^b
*/
int[][] matrixFastPow(int[][] A, int b) {
    int n = A.length;
    int[][] mat = new int[n][n], res = new int[n][n];
    // res 初始化为单位矩阵
    for (int i = 0; i < n; i++) {
        res[i][i] = 1;
    }
    // mat 克隆 A
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            mat[i][j] = A[i][j];
        }
    }
    // 代入常规的快速幂中
    while (b != 0) {
        if ((b & 1) == 1) {
            res = mul(res, mat);
        }
        mat = mul(mat, mat);
        b >>>= 1;	
    }
    return res;
}
```

- [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)
-  [552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)



### 蓄水池抽样

**描述**：总样本数为 N，对于遇到的第 $i$ 个样本（$i$ 从 1 开始算），设其被选择的概率为 $\cfrac K i$，最终获得 $K$ 个样本，且满足每个样本被选择的概率为 $\cfrac K N$​。

**应用**：一次遍历即可获得 K 个随机数，一般用于解决未知大小的数据流或数据量很大的情况。

**证明**：前 $K$​​ 个样本放入容量为 $K$​ 的容器中，每个样本都能放入，故概率均为 $p(1) = p(2) = \cdots = p(K) = 1$​​

对于第 $K+1$​​ 个样本，被保留在容器中的概率为 $\cfrac K {K+1}$​​，则需要在容器中随机选择一个样本替换，前 $K$ 个样本被保留的概率即为
$$
p(1) = p(2) = \cdots = p(k) = 1 \times (\cfrac 1 {K+1} + \cfrac K {K+1} \times \cfrac {K-1} K) = \cfrac K {K+1}
$$
对于第 $K+2$​ 个样本，被保留在容器中的概率为 $\cfrac K {K+2}$​，则需要在容器中随机选择一个样本替换，前 $K+1$ 个样本被保留的概率即为
$$
p(1) = p(2) = \cdots = p(k) = p(k+1) = \cfrac K {K+1} \times (\cfrac 2 {K+2} + \cfrac K {K+2} \times \cfrac {K-1} K) = \cfrac K {K+2}
$$
……

不失一般性地，对于第 $i~(i > K)$​​​​ 个样本，其保留概率为 $\cfrac K i$，则前 $i-1$ 个样本 $n_r~(r ∈ (1, i-1))$ 被保留在容量为 $K$​​​​​ 的容器中的概率为
$$
p(n_r) = \cfrac K {i-1} \times (  \cfrac {i-K} i + (\cfrac K i \times \cfrac {K-1} K)) = \cfrac K i
\\
\\
p = p(\text{在 }i-1 \text{ 轮保留下来}) \times \Big( p(\text{样本 }i\text{ 未被选择}) + p(\text{样本 }i\text{ 被选择}) * p(\text{未被样本 } i \text{ 替换})\Big)
$$

当 $i = N$​ 时，即有
$$
p(n_1) = p(n_2) = \cdots = p(n_{N-1}) = p(n_N) = \cfrac K N
$$

```java
/**
* 按照水塘抽样从 nums 数组中随机抽取 k 个数，每个数被抽到的概率相同
* @params nums 待抽取数据
* @params k 抽取的样本数
* @return 返回抽取样本
*/
int[] reservoirSampling(int[] nums, int k) {
    int[] res = new int[k];
    Random r = new Random();
    for (int i = 0; i < k; i++) {
        res[i] = nums[i];
    }
    for (int i = k; i < nums.length; i++) {
        int t = r.nextInt(i+1);
        // 抽到了
        if (t < k) {
            res[t] = nums[i];
        }
    }
    return res;
}
```

[LeetCode 水塘抽样相关题目](https://leetcode-cn.com/tag/reservoir-sampling/problemset/)



### 约瑟夫环

给出 n 个人围成一圈，，编号为 1 ~ n，从编号 1 开始报数，数到 m 的人被淘汰，下一个人从 1 重新报数，求出获胜者。

```java
int solve(int n, int m) {
	int p = 0;	// 获胜者的位置，由于是从后往前倒推，所以初始位置为 0
    for (int i = 2; i <= n; i++) {
        // 求出获胜者在本轮的位置
        p = (p + m) % i;
    }
    // 编号从 1 开始，所以要补上 1
    return p+1;    
}
```

[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)



### 埃式筛法

$O(maxNumber)$ 时间复杂度找到小于等于 `maxNumber` 的所有质数

```java
boolean[] getPrime(int maxNumber) {
    boolean[] isNotPrime = new boolean[maxNumber + 1];
    // 埃式筛法
    for (int i = 2; i < Math.sqrt(maxNumber); i++){ 
        if (!isNotPrime[i]) { // 如果是质数，筛掉质数的倍数
            for (int j = i*i; j <= maxNumber; j+=i){ // 筛掉i的倍数（1~i-1倍已经在前面筛过了，所以不用考虑）	
                isNotPrime[j] = true;  // j必不是质数
            }
        }
    } 
    return isNotPrime;
}	
```



### 组合（+乘法逆元）

我们知道计算组合数的公式：
$$
C_n^k = \cfrac {n!} {k!(n-k)!} 
$$

在数很大的情况下需要取模 $MOD = 1e9 + 7$ ，而取模的操作只包含了 `+ - *`，并不能使用 `/`，故需要用到乘法逆元。

**乘法逆元**：
$$
\cfrac b a \equiv b \cdot a^{-1} ~(mod ~m)
$$
即在取模运算中，只要找到一个数 $q$，使 $ a \cdot q \equiv 1 ~(mod ~m)$ ，则有 $\cfrac b a \equiv b \cdot q ~(mod ~m)$ 。计算乘法逆元需要用到费马小定理

**费马小定理**：若 $p$ 是质数，且 $a ~mod~ p \ne 0$， 则有 
$$
a ^  {p-1} \equiv 1 ~ (mod ~p)
$$

把模数 $m$ 带入 $p$ 得：

$$
\begin{align*}
a ^ {m-1} &\equiv 1 ~(mod ~m) \\
\lrArr a^{m-1} a^{-1} &\equiv a ^{-1} ~(mod ~m) \\
\lrArr a^{m-2} aa^{-1} &\equiv a^{-1} ~(mod ~m) \\
\lrArr a^{-1} &\equiv a ^{m-2} ~(mod ~m)
\end{align*}
$$

故只需要计算 $a ^{m-2}$  即可（用快速幂）



```java
static int size = 100000; 
static int MOD = (int) 1e9 + 7;
static long[] fac, inv; // fac[i] 为 i!，inv[i] 表示 fac[i] 的乘法逆元
// 初始化，计算 fac 和 inv
static void initialize(int size) {
    fac = new long[size + 1]; inv = new long[size + 1];
    fac[0] = inv[0] = 1;
    for (int i = 1; i <= size; i++) {
        fac[i] = fac[i-1] * i % MOD;
        // 快速幂计算乘法逆元
        inv[i] = fastPow(fac[i], MOD - 2);
    }
}

// 计算 C(n, k)
long comb(int n, int k) {
    // n! / (k! * (n-k)!)
    return fac[n] * inv[k] % MOD * inv[n-k] % MOD;
}

static long fastPow(long a, long b) {
    // int MOD = 1000000007;
    long base = a % MOD, res = 1;
    while (b != 0) {
        if ((b & 1) == 1) {
            res = res * base % MOD;
        }
        base = base * base % MOD;
        b >>>= 1;	
    }
    return res % MOD;
}
```

[1830. 使字符串有序的最少操作次数](https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-string-sorted/)



# 数据结构

### 线段树

具体问题具体分析，这里默认使用区间赋值操作，如果要用区间增值，把特定位置的 `=` 改成 `+=` 即可

```java
class SegmentTree {
    private int[] tree, nums, lazy;
    final int UNUSE = 0; // 注意这里，如果是区间赋值，UNUSE 需要保证一定不能等于区间赋值！
    public SegmentTree(int[] nums) {
        int n = nums.length;
        tree = new int[4*n];
        lazy = new int[4*n];    // lazy tag
        Arrays.fill(lazy, UNUSE);
        this.nums = nums;
        buildTree(0, 0, n-1);
    }

    /**
    * 构建线段树
    * @param node 当前节点对应到 tree 的下标
    * @param start 当前节点对应的 nums 区间起点
    * @param end 当前节点对应的 nums 区间终点
    */
    private void buildTree(int node, int start, int end) {
        if (start == end) {
            tree[node] = nums[start];
            return;
        }
        int mid = start + (end - start) / 2;
        int leftNode  = node * 2 + 1;
        int rightNode = node * 2 + 2;

        buildTree(leftNode, start, mid);
        buildTree(rightNode, mid+1, end);

        tree[node] = tree[leftNode] + tree[rightNode];
    }

    private void pushDown(int node, int start, int end) {
        if (lazy[node] == UNUSE) {
            return;
        }
        int leftNode = node * 2 + 1;
        int rightNode = node * 2 + 2;
        int mid = start + (end - start) / 2;
        
    	// 如果方案为区间增值，把下面四个 = 改成 += 即可
        tree[leftNode] = lazy[node] * (mid - start + 1);
        lazy[leftNode] = lazy[node];
        tree[rightNode] = lazy[node] * (end - mid);
        lazy[rightNode] = lazy[node];
        // 清空当前 lazy tag
        lazy[node] = UNUSE;
    }
    
    /**
    * 更新线段树
    * @param node 当前节点对应到 tree 的下标
    * @param start 当前节点对应的 nums 区间起点
    * @param end 当前节点对应的 nums 区间终点
    * @param left 待更新的 nums 左端点
    * @param right 待更新的 nums 右端点
    * @param val 区间设定的值
    */
    private void updateTree(int node, int start, int end, int left, int right, int val) {
        // 当前节点被区间完全覆盖，更新节点并设置 lazy tag，这样就没必要向下更新了
        if (left <= start && end <= right) {
            // 如果方案为区间增值，把下面两个 = 改成 += 即可
            tree[node] = (end - start + 1) * val;  
            lazy[node] = val;   
            return;
        }

        // 把当前节点的 lazy tag 传递到下一层
        pushDown(node, start, end);

        int mid = start + (end - start) / 2;
        int leftNode = 2 * node + 1;
        int rightNode = 2 * node + 2;

        // 需要更新左子树
        if (left <= mid) {
            updateTree(leftNode, start, mid, left, right, val);
        } 
        // 需要更新右子树
        if (right > mid) {
            updateTree(rightNode, mid+1, end, left, right, val);
        } 
        // 更新当前节点
        tree[node] = tree[leftNode] + tree[rightNode];
    }

    /** 
    * 查询线段树
    * @param node 当前节点对应到 tree 的下标
    * @param start 当前节点对应的 nums 区间起点
    * @param end 当前节点对应的 nums 区间终点
    * @param left 待查询的 nums 区间起点
    * @param right 待查询的 nums 区间终点
    */
    private int queryTree(int node, int start, int end, int left, int right) {
        // 查找范围不在当前范围内
        if (right < start || left > end) {
            return 0;
        }
        // 当前范围就在查找范围中，直接返回
        if (start >= left && end <= right) {
            return tree[node];
        }
        
        // 部分范围在查找区间中，先把 lazy tag 传下去
        pushDown(node, start, end);

        int mid = start + (end - start) / 2;
        int leftNode = 2 * node + 1;
        int rightNode = 2 * node + 2;
        int leftSum = queryTree(leftNode, start, mid, left, right);
        int rightSum = queryTree(rightNode, mid+1, end, left, right);
        return leftSum + rightSum;
    }

    /**
    * 更新 nums 下标的值
    * @param index 对应的 nums 下标
    * @param val 更新的值
    */
    public void update(int index, int val) {
        updateTree(0, 0, nums.length-1, index, index, val);	
    }

    /**
     * 区间更改
     * @param left nums 左端点
     * @param right nums 右端点
     * @param val 设定的值
     */
    public void update(int left, int right, int val) {
        updateTree(0, 0, nums.length - 1, left, right, val);
    }
    
    /**
    * 查询 nums 的区间和
    * @param left 区间起点
    * @param right 区间终点
    */
    public int query(int left, int right) {
        return queryTree(0, 0, nums.length-1, left, right);
    }
}
 
```



[6030. 由单个字符重复的最长子字符串](https://leetcode-cn.com/problems/longest-substring-of-one-repeating-character/)

[307. 区域和检索 - 数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)

[LCP 52. 二叉搜索树染色](https://leetcode-cn.com/problems/QO5KpG/)



#### 补充：zkw 线段树

与普通的自顶向下线段树不同，zkw线段树采用自底向上的更新方式。

这里只记录单点修改和区间查询。

```java
class ZKWSegmentTree {
    int[] tree;
    int base = 1;
    public ZKWSegmentTree(int[] nums) {
        int n = nums.length;
        // 找到能容纳整个 nums 的满二叉树的层
        while (base <= n) base <<= 1;
        // 最后一层有 base 个节点，那么前面几层加起来就有 base - 1 个节点，总共就有 base*2 - 1 个节点
        tree = new int[base << 1];
        // 把 nums 放到最后一层，注意 base 位置是空的
        for (int i = 0; i < nums.length; i++) {
            tree[base + 1 + i] = nums[i];
        }
        // 向上更新
        for (int i = base - 1; i > 0; i--) {
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
        }
    }

    public void update(int index, int val) {
        // 树的起始节点为 1
        index = base + index + 1;
        tree[index] = val;
        // 向上更新
        for (int i = index >> 1; i > 0; i >>= 1) {
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
        }
    }

    public int query(int left, int right) {
        // 将 [left, right] 变为开区间的 (left - 1, right + 1)
        // 这里不用担心 right 超出范围的情况
        left = base + left;
        right = base + right + 2;
        int res = 0;
        // left ^ right ^ 1 == 0 表示 left 和 right 是兄弟节点
        while ((left ^ right ^ 1) != 0) {
            // left 是左孩子，说明右孩子在范围里
            if ((left & 1) == 0) {
                res += tree[left ^ 1];
            }
            // right 是右孩子，说明左孩子在范围里
            if ((right & 1) == 1) {
                res += tree[right ^ 1];
            }
            // 到父节点
            left >>= 1;
            right >>= 1;
        }
        return res;
    }
}
```



---



### 树状数组

![img](https://markdown-img-1306901910.cos.ap-nanjing.myqcloud.com/20200717113236761.png)

```java
class BinaryIndexedTree {
    int[] tree, nums;
    int n;
    public BinaryIndexedTree(int[] nums) {
        n = nums.length;
        this.nums = nums;
        // tree 下标以 1 开始
        tree = new int[n+1];
        for (int i = 0; i < n; i++) {
            add(i, nums[i]);
        }
    }

    /**
    * 在指定下标增加值
    * @param idx 指定数组下标
    * @param val 要增加的值（不是修改，是增加）
    */
  	public void add(int idx, int val) {
        for (int i = idx + 1; i <= n; i += lowbit(i)) {
            tree[i] += val;
        }
    }

    /**
    * 更新指定下标的值
    * @param idx 指定数组下标
    * @param val 要更新的值
    */
    public void update(int idx, int val) {
        add(idx, val - nums[idx]);
        nums[idx] = val;
    }

    /**
    * 查找前缀和
    * @param idx 查询的右端点
    * @return nums[0:idx] 的和
    */
    public int query(int idx) {
        int res = 0;
        for (int i = idx + 1; i > 0; i-= lowbit(i)) {
            res += tree[i];
        }
        return res;
    }
    
    /**
    * 查询[left, right]区间和
    * @param left 左端点（闭）
    * @param right 右端点（闭）
    */
    public int query(int left, int right) {
        return query(right) - query(left - 1);
    }

    private int lowbit(int x) {
        return x & -x;
    }
}
```



[1649. 通过指令创建有序数组](https://leetcode-cn.com/problems/create-sorted-array-through-instructions/)

[5999. 统计数组中好三元组数目](https://leetcode-cn.com/problems/count-good-triplets-in-an-array/)

---



### 0/1字典树

```java
class Trie {
    class TrieNode {
        TrieNode[] son = new TrieNode[2];
        int[] cnt = new int[2];	// 统计子结点路径数，离线删除
    }
    
    TrieNode root;
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(int val) {
        insertAndDelete(val, 1);
    }
    
    public void delete(int val) {
        insertAndDelete(val, -1);
    }
    
    /**
    * 在树中插入/删除一个数
    * @param val 待插入/删除的数
    * @param s 标记符号，1 表示插入，-1 表示删除
    * @return null
    */
    private void insertAndDelete(int val, int s) {
        TrieNode node = root;
        for (int i = 30; i >= 0; i--) {
            int v = ((1 << i) & val) >>> i;
            if (node.son[v] == null) {
                node.son[v] = new TrieNode();
            }
            node.cnt[v] += s;
            node = node.son[v];
        }
    }
    
    /**
    * 找到树中与 val 异或的最大值
    * @param val 需要异或的 val
    * @return 返回最大异或结果
    */
    public int getXorMax(int val) {
        TrieNode node = root;
        int res = 0;
        for (int i = 30; i >= 0; i--) {
            int v = ((1 << i) & val) >> i;
            // 找异或最大，优先找反方向
            if (node.cnt[v^1] > 0) {
            	// 有反方向的数，该位的结果为 1
                res |= 1 << i;
                node = node.son[v^1];
            } else if (node.cnt[v] > 0) {
                node = node.son[v];
            } else {
                return -1;
            }
        }
        return res;
    }
}
```

[421. 数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/)

[1803. 统计异或值在范围内的数对有多少](https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/)

[1707. 与数组中元素的最大异或值](https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/)





### AC 自动机

基于 Trie 的特殊结构，节点新增了 fail 指针。详情可参阅：[AC 自动机](https://oi-wiki.org/string/ac-automaton/)

作用：字符流匹配。

```java
class StreamChecker {
    class Node {
        Node[] son = new Node[26];
        Node fail;
        boolean isEnd;
    }
    Node root = new Node(), dummy = new Node();
    Node node = root;
    public StreamChecker(String[] words) {
        build(words);
    }

    public void build(String[] words) {
        // dummy 节点能省去很多代码
        root.fail = dummy;
        for (int i = 0; i < 26; i++) {
            dummy.son[i] = root;
        }
        // Trie 的插入操作
        for (String word : words) {
            Node cur = root;
            for (char c : word.toCharArray()) {
                if (cur.son[c - 'a'] == null) {
                    cur.son[c - 'a'] = new Node();
                }
                cur = cur.son[c - 'a'];
            }
            cur.isEnd = true;
        }

        // 找 fail 
        Queue<Node> q = new LinkedList<>(){{ offer(root); }};
        while (!q.isEmpty()) {
            Node cur = q.poll();
            for (int i = 0; i < 26; i++) {
                Node failPtr = cur.fail.son[i];
                if (cur.son[i] != null) {
                    cur.son[i].fail = failPtr;
                    q.offer(cur.son[i]);
                } else {
                // 特殊处理，改变字典树结构，省去 while 循环
                    cur.son[i] = failPtr;
                }
                // 省去在 query 中向上查找的步骤
                if (failPtr.isEnd) {
                    cur.son[i].isEnd = true;
                }
            }
        }
    }    
    public boolean query(char ch) {
        // 这里的 query 查询字符流添加 ch 后的后缀是否在给定的 words 中
        node = node.son[ch - 'a'];
        return node.isEnd;
    }
}
```



[1032. 字符流](https://leetcode-cn.com/problems/stream-of-characters/)



### 并查集

```java
class UnionFind {
    int[] parent, size;
    public UnionFind(int n) {
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    /**
    * 合并两个节点所在的集合
    * @param x 待合并的一个节点
    * @param y 待合并的另一个节点
    * @return null
    */
    public void union(int x, int y) {
        int rootX = find(x), rootY = find(y);
        if (rootX == rootY) { // 在同一个集合中
            return;
        }
        if (size[rootX] > size[rootY]) { // 按秩合并，优化时间
            int t = rootX;
            rootX = rootY;
            rootY = t;
        }
        parent[rootX] = rootY;
        size[rootY] += size[rootX];
    }
    
    
    public boolean isUnion(int x, int y) {
        return find(x) == find(y);
    }
    
    /**
    * 查找根节点
    * @param x 待查找的节点
    * @return 返回根节点
    */
    private int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  	 // 路径压缩
        }
        return parent[x];
    }
}
```



### 跳表 Skiplist

Redis 使用的数据结构

```java
class Skiplist {
    // P 和 MAX_LEVEL 取值参考自 Redis 源码
    private static int MAX_LEVEL = 32;  // 允许的最大层数
    private static double P = 0.25;     // 生成 level 层的概率为 P^(level-1)

    class SkiplistNode {
        int val;
        SkiplistNode[] next;
        public SkiplistNode(int val, int level) {
            this.val = val;
            next = new SkiplistNode[level];
        }
    }

    private int level = 1;              // 当前跳表中的最大层数
    private SkiplistNode head;
    public Skiplist() {
        head = new SkiplistNode(-1, MAX_LEVEL);
    }
    
    public boolean search(int target) {
        SkiplistNode prev = head;
        for (int i = level - 1; i >= 0; i--) {
            prev = findNodeOnLevel(prev, target, i);
            if (prev.next[i] != null && prev.next[i].val == target) {
                return true;
            }
        }
        return false;
    }
    
    public void add(int num) {
        int level = getRandomLevel();
        SkiplistNode newNode = new SkiplistNode(num, level);
        SkiplistNode prev = head;
        this.level = Math.max(this.level, level);
        for (int i = this.level - 1; i >= 0; i--) {
            // 这个位置很重要
            prev = findNodeOnLevel(prev, num, i);
            if (i < level) {
                newNode.next[i] = prev.next[i];
                prev.next[i] = newNode;
            }
        }
    }
    
    public boolean erase(int num) {
        SkiplistNode prev = head;
        boolean f = false;
        for (int i = level - 1; i >= 0; i--) {
            prev = findNodeOnLevel(prev, num, i);
            if (prev.next[i] != null && prev.next[i].val == num) {
                f = true;
                prev.next[i] = prev.next[i].next[i];
            }
        }
        return f;
    }

    /**
    * 获得随机层数
    * @return 返回层数
    */
    private int getRandomLevel() {
        int level = 1;
        while (Math.random() < P && level < MAX_LEVEL) {
            level++;
        }
        return level;
    }

    /**
    * 在指定层数查找目标值对应的节点位置
    * @param node 起始的查找节点
    * @param target 目标值
    * @param level 指定层数
    * @return 返回的 node.next[level] 即为目标节点的位置
    */
    private SkiplistNode findNodeOnLevel(SkiplistNode node, int target, int level) {
        while (node.next[level] != null && node.next[level].val < target) {
            node = node.next[level];
        }
        return node;
    }
}
```



# 算法

### 快速排序

因为 [面试题 17.14. 最小K个数](https://leetcode-cn.com/problems/smallest-k-lcci/) 总是在边界处理的时候遇到问题，故记录一下，标准的快排是咋做的

```java
void quickSort(int[] arr, int l, int r) {
	// 先确定主元，可以用 random，也可以直接用最左边的
    // int randIdx = new Random().nextInt(r - l + 1) + l;
    // swap(arr, randIdx, l);
    // 这里直接用最左边的当主元了，注意！！！ i 从 l 开始，不要从 l + 1 开始
    if (l >= r) return;
    int i = l, j = r;
    int pivot = arr[l];
    while (i < j) {
        // ※ 先移动右边的指针 ※ 要用到【=】号
        while (i < j && arr[j] >= pivot) j--;
        while (i < j && arr[i] <= pivot) i++;
        swap(arr, i, j);
    }
    // ※ 交换 i 和 l，此时 i 就是主元的正确位置
    swap(arr, i, l);
    
    /* 如果是做 最小 K 个数的话，就按照 k 来选择排序哪一半
    if (i == k) return;
    else if (i > k) quickSort(arr, l, i - 1);
    else quickSort(arr, i + 1, r);
    */
    
    /* 如果是标准快排，左右直接排序
    quickSort(arr, l, i - 1);
    quickSort(arr, i + 1, r);
    */
}
```



### 回文串预处理

```java
/** 
* 预处理字符串，判断各子串是否是回文串
* @param s 待处理的字符串
* @return [i][j] 表示 s[i:j] 是否是回文串
*/
boolean[][] preHandlePalidrome(String s) {
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    for (int i = 0; i < n; i++) {
        Arrays.fill(dp[i], true);
    }
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i + len - 1 < n; i++) {
            int j = i + len - 1;
            dp[i][j] = dp[i+1][j-1] && s.charAt(i) == s.charAt(j);
        }
    }
    return dp;
}
```



### Manacher算法

$O(n)$ 时间复杂度下解决回文子串问题

将原字符串的所有空隙（包括头尾）插入 【#】，保证每个回文子字符串都为奇数



现在仅考虑奇数回文串的计算：

记 `dp[i]` 为以 `i` 为中心的最长回文串半径（包括 `i`，如对于 `ababa`，`dp[2] = 3`）

1. 记录当前回文字符串最远的右边界及其对应的左边界，记为 `l`，`r`。（初始化 `l = 0, r = -1`）
2. 遍历到 `s[i]` 时，考虑 `s[i]` 是否在 `l~r` 范围内
   1. `i > r`，无法根据前面的数据计算回文串，只能退化为最朴素的中心扩散法。
   2. `i <= r`，考虑 `i` 在 `[l:r]` 中的翻转结果 `j`，即 `j = l + r - i`，由于回文串的性质，**在 `[l:r]` 范围内**，以 `j` 为中心的回文串长度**等于**以 `i` 为中心的回文串长度。
      - 考虑到特殊情况，若 `i` 的回文串右端点能扩展到 `r` 之外，实际答案会大于 `dp[j]`，对于 `r` 之外部分的比较，仍采用朴素的中心扩散法。



在加入【#】 后，可以全部考虑成奇数回文串的计算。我们记实际字符串为 `S`，插入【#】之后的字符串为 `SS`，那么在 `SS` 中计算得到的 `dp[i]` 相当于其在 `S` 中对应位置的回文串长度 + 1。什么对应位置呢？即字母对应字母，# 对应字母间空格。

举例：`ababac` => `#a#b#a#b#a#c#`，`#a#b#a#b#a#` 对应 `ababa`，`dp[i] = len(#a#b#a) = 6`，实际长度 `len(ababa) = 5`

偶数情况同理：`abbac` => `#a#b#b#a#c#`，那么 `#a#b#b#a#` 对应 `abba`，`dp[i] = len(#a#b#) = 5`，实际长度 `len(abba) = 4`



```java
void manacher(String s) {
    char[] c = new char[s.length() * 2 + 1];
    int n = c.length, _i = 1;
    c[0] = '#';
    for (char ch : s.toCharArray()) {
        c[_i++] = ch;
        c[_i++] = '#';
    }
    int[] dp = new int[n];
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = i > r ? 1 : Math.min(dp[l + r - i], r - i + 1);
        // 朴素的中心扩散法
        while (0 <= i - k && i + k < n && c[i-k] == c[i+k]) k++;
        dp[i] = k--;
        // 更新 l,r
        if (i + k > r) {
            r = i + k;
            l = i - k;
        }
    }
}
// 实际情况长度 = dp[i] - 1
/* 求最长回文子串：
for (int d : dp) res = Math.max(res, d - 1);
*/

/* 求所有回文串个数： 
for (int d : dp) {
	int t = d - 1;
	res += t / 2 + t % 2;
}
*/
```



 [1960. 两个回文子字符串长度的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/)





### Morris 遍历

$O(n)$ 时间，$O(1)$ 空间复杂度的二叉树遍历

```java
while (root != null) {
    if (root.left != null) {
        TreeNode predecessor = root.left;
        // 找到 root 左子树的最右节点
        while (predecessor.right != null && predecessor.right != root) {
            predecessor = predecessor.right;
        }
        // 第一次遍历到，将 predecessor.right 设为 root
        // 目的是方便最后遍历完回到 root
        if (predecessor.right == null) {
            predecessor.right = root;
            /* 前序遍历位置 */
            // 进入左子树
            root = root.left;
            continue;
        } 
        // 第二次遍历到 predecessor.right == root，说明左子树已经全部遍历完了，可以进入右子树
        // 先恢复 predecessor.right
        predecessor.right = null;
    }
    /* 中序遍历位置 */
    // 进入右子树
    root = root.right;
}
```

[99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)



### 图

#### Dijkstra 单源最短路径

```java
int[] dijkstra(List<Integer>[] graph, int src) {
    int n = graph.length;
    PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]){{ offer(src); }};
    int[] dist = new int[n];
//    int[] path = new int[n];
	Arrays.fill(dist, INF);
//    Arrays.fill(path, -1);
   	dist[src] = 0;
    boolean[] vis = new boolean[n];
    while (!pq.isEmpty()) {
        int cur = pq.poll()[0];
        if (vis[cur]) continue;
        vis[cur] = true;
        for (int nxt : graph[cur]) {
            if (!vis[nxt] && dist[cur] + graph[cur][nxt] < dist[nxt]) {
                dist[nxt] = dist[cur];
//                path[nxt] = cur;
                pq.offer(new int[]{nxt, dist[nxt]});
            }
        }
    }
    return dist;
//    return path;
}
```



#### Floyd 多源最短路径

```java
int[][] floyd(int[][] graph) {
    int n = graph.length;
    int[][] dist = new int[n][n];
//    int[][] path = new int[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = graph[i][j];
//            path[i][j] = -1;
        }
    }
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            if (graph[i][k] == INF) continue;
            for (int j = 0; j < n; j++) {
                if (dist[i][k] + dist[k][j] <= dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
//                    path[i][j] = k;
                }
            }
        }
    }
    return dist;
//    return path;
}
```



#### 拓扑排序

```java
boolean topSort(List<Integer>[] graph) {
    int n = graph.length;
    int[] indegree = new int[n];
    for (int i = 0; i < graph.length; i++) {
        for (int j : graph[i]) {
            indegree[j]++;
        }
    }
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < n; i++) {
        if (indegree[i] == 0) {
            q.offer(i);
        }
    }
    List<Integer> topOrder = new ArrayList<>();
    while (!q.isEmpty()) {
        int cur = q.poll();
        topOrder.add(cur);
        for (int nxt : graph[cur]) {
            /* do something... */
            if (--indegree[nxt] == 0) {
                q.offer(nxt);
            }
        }
    }
    // 检查是否有环
    return topOrder.size() == n;
}
```



#### Prim 最小生成树

Minimum Spanning Tree

基于贪心，任选一点作为起始点。每次选择距离生成树集合里的点最近的一点，放入集合中。

```java
int MST(int start, int[][] graph) {
    int n = graph.length;
    int[] dist = new int[n];	// 记录生成树到某个点的距离
    int[] parent = new int[n];	// 生成树的父子关系
    for (int i = 0; i < n; i++) {
        dist[i] = graph[start][i]; // 初始化为起点到当前点的距离
        parent[i] = start;		// 先暂时把父节点设成 start
    }
    int vCount = 1; // 记录 MST 的大小，已经算上 start 了
    int totalWeight = 0;	// 记录 MST 的总权值
    parent[start] = -1; // 根节点
    while (vCount < n) {
        // 先找到离 MST 最近的节点
        int v = -1;
        for (int i = 0; i < n; i++) {
            if (dist[i] > 0 && dist[i] < minDist) {
                minDist = dist[i];
                v = i;
            }
        }
        // 找不到
        if (v == -1) break;
        // 把 v 放入 MST 中
        vCount++;
        totalWeight += dist[v];
        // 找 v 的邻接点
        for (int i = 0; i < n; i++) {
            if (dist[i] > 0 && graph[v][i] < dist[i]) {
                // 更新 dist
                dist[i] = graph[v][i];
                parent[i] = v; // 更新树
            }
        }
    }
    // 无法创建最小生成树（图不连通）
    if (vCount < n) return -1;
    return totalWeight;
}
```





#### Kruskal 最小生成树

基于[并查集](#并查集)，每次取出所有边中最小权重的边，合并顶点。

```java
class Edge {
    int start, end;
    int weight;
    public Edge(int start, int end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }
}
int MST(int n, List<Edge> edge) {
    // 按照 weight 排序
    PriorityQueue<Edge> pq = new PriorityQueue<>((o1, o2) -> o1.weight - o2.weight);
    for (Edge e : edge) {
        pq.offer(e);
    }
    int totalWeight = 0;
    int vCount = 0;
    UnionFind uf = new UnionFind(n);
    while (!pq.isEmpty()) {
        Edge cur = pq.poll();
        if (uf.isUnion(cur.start, cur.end)) continue;
        uf.union(cur.start, cur.end);
        totalWeight += cur.weight;
        vCount++;
    }
    if (vCount < n) return -1;
    return totalWeight;
}
```





#### A*寻路

```java
PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) -> o1.F - o2.F);
int[] dist; // dist[i] 表示 i 到 src 的距离
int[] comeFrom; // comeFrom[i] 表示 i 的上一个节点

while (!pq.isEmpty()){
    Node cur = pq.poll();
    if (cur.id == target) {
        break;
    }
    for (int next : cur 的所有邻居) {
        int newCost = dist[cur] + graph[cur][next];
        if (neighbor 未访问过 || newCost < dist[next])  {
            int f = newCost + getH(next, target);
 			pq.offer(new Node(next, f));
            comeFrom[next] = cur.id;
        }
    }
}

List<Integer> path = new ArraytList<>();
for (int cur = target; cur != -1; cur = comeFrom[cur]) {
    path.add(cur);
}
path.reverse();
```



#### Hierholzer 算法（欧拉图）

欧拉回路：通过图中所有边恰好一次且行遍所有顶点的回路（欧拉图）

欧拉通路：通过图中所有边恰好一次且行遍所有顶点的通路（半欧拉图）

简要概述：一笔画思想，从一点出发能一笔连完所有的点和边



算法思想：

1. 从起点出发，进行深度优先搜索。

2. 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。

3. 如果没有可移动的路径，则将所在节点加入到栈中，并返回。

对于半欧拉图来说，没有可移动路径就是欧拉通路的终点，对于欧拉图来说，起点即终点。所以不妨倒着来考虑，每次 DFS 时都尽可能地将该节点对应的边删除，只要遍历到当前节点不能走时，就加入栈中。这样第一个入栈的一定是终点，第二个入栈的是倒数第二个点……以此类推。



```java
void dfs(cur) {
    while (hasNext(cur)) {
        // 记录下一个顶点位置
        next = next(cur);
        // 删掉当前边
        deleteEdge(cur, next);
        // 继续 dfs
        dfs(next);
    }
    res.add(cur)
}
// 最后要倒序
Collections.reverse(res);
```



[332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

[2097. 合法重新排列数对](https://leetcode-cn.com/problems/valid-arrangement-of-pairs/)

[753. 破解保险箱](https://leetcode.cn/problems/cracking-the-safe/)



### KMP

```java
/**
* 使用 KMP 查找字符串位置
* @param s 原串
* @param p 匹配串
* @return s 在 p 中出现的第一个位置
*/
public int strStr(String s, String p) {
    if (p.length() == 0) return 0;
    /* KMP 算法，O(m+n) */
    // KMP 算法就是利用匹配串的相同前后缀长度，来减少原串的重复匹配过程
    // 最为核心的部分是 next 数组

    // 获得模式串的 next 数组
    int[] next = new int[p.length()];
    // i 为前缀字符串的结尾指针，j 为后缀字符串的结尾指针
    for (int i = 0, j = 1; j < p.length(); j++) {
        // 相同的前后缀不匹配！，找到之前匹配过的前缀
        while(i > 0 && p.charAt(i) != p.charAt(j)) {
            // next[i-1] 记录了 p[0 : i-1] 的最长相同前后缀长度
            // 因为也是前缀长度，所以 i 直接定位到 next[i-1]
            // 此时前缀 p[0 : i-1] 和后缀 p[j-i : j-1] 仍相同
            i = next[i-1];
        }
        
        // 此时若 p[i] == p[j]，说明了最长相同前后缀的长度就是 len(p[0:i]) = i+1;
        // 若 p[i] != p[j]，说明连第一个字母都不匹配，i 仍为 0
        if (p.charAt(i) == p.charAt(j)) {
            i++;
        }
        next[j] = i;
    }
    
    // i 为 s 的指针，j 为 p 的指针
    for (int i = 0, j = 0; i < s.length(); i++) {
        while (j > 0 && s.charAt(i) != p.charAt(j)) {
            // 不相同，找到 s 和 p 之前匹配过得相同的部分
            // 此时 p[0 : j-1] 和 s[i-j : i-1] 是匹配的
            // 所以 p 的前缀 [0 : next[j-1]] 和 s 的后缀 [i-1-next[j-1]:i-1] 是匹配的          
            j = next[j-1];
        }
        if (s.charAt(i) == p.charAt(j) && ++j == p.length()) {
            return i-j+1;
            // j = next[j-1]; // 若要查询所有的位置，j 要变
        }
    }
    return -1;
}
```



#### 补充：Z 函数 （扩展 KMP）

对于个长度为 $n$ 的字符串 $s$。定义函数 $z[i]$ 表示 $s$ 和 $s[i, n-1]$（即以 $s[i]$ 开头的后缀）的最长公共前缀（LCP）的长度。$z$ 被称为 $s$ 的 **Z 函数**。特别地，$z[0] = 0$。

Z 函数的计算过程类似 Manacher 算法，详情可参阅 [OI-Wiki](https://oi-wiki.org/string/z-func/)。

在计算 $z[i]$ 的过程中：

- 如果 $i \le r$，那么根据 $[l,r]$ 的定义有 $s[i, r] = s[i - l, r- l]$，因此 $ z[i] \ge \min(z[i-l], r-i+1)$。这时：
  - 若 $z[i - l] < r - i + 1$，则 $z[i] = z[i - l]$。
  - 否则 $z[i-l] \ge r - i + 1$，这时我们令 $z[i] = r - i + 1$，然后暴力枚举下一个字符扩展 $z[i]$ 直到不能扩展为止。
- 如果 $i > r$，那么我们直接按照朴素算法，从 $s[i]$ 开始比较，暴力求出 $z[i]$。
- 在求出 $z[i]$ 后，如果 $i + z[i] - 1 > r$，我们就需要更新 $[l,r]$，即令 $l = i, r = i + z[i] - 1$。

```java
int[] z_function(String s) {
    int n = s.length();
    int[] z = new int[n];
    // [l, r] 是当前维护的匹配段，满足：[l, r] 与前缀 [0, r - l]匹配，保证 l <= i
    for (int i = 1, l = 0, r = 0; i < n; i++) {
        // 可知 [i, r] 与 [i-l, r-l] 匹配
        if (i <= r && z[i - l] < r - i + 1) {
            z[i] = z[i - l];
        } else {
            // 此时 i > r 或 r - i + 1 更小
            z[i] = Math.max(0, r - i + 1);
            // 需要用朴素的暴力匹配增加 z[i] 的值
            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;
        }
        // 更新 [l, r]
        if (i + z[i] - 1 > r) {
            l = i;
            r = i + z[i] - 1;
        }
    }
    return z;
}
```



[6036. 构造字符串的总得分和](https://leetcode-cn.com/problems/sum-of-scores-of-built-strings/)



### Rabin-Karp 字符串哈希

对于长度为 $n$ 的字符串 $s$，用长度为 $n + 1$ 的数组 `hash[n + 1]` 统计其哈希值，用长度为 $n + 1$ 的数组 `b[n + 1]` 计算基数 `base` 的次方。

计算 $s$ 的子串 `s[i:j]`（包含 `i`，不包含 `j`）的哈希值的计算方式为：
$$
hash(s[i:j]) = (hash[j] - b[j - i] \times hash[i]~ \%~ mod + mod)~ \%~ mod
$$

```java
long h = (hash[j] - b[j - i] * hash[i] % mod + mod) % mod;
```



```java
/**
* Rabin-Karp O(m + n)
*/
public int strStr(String s, String p) {
    int n = s.length(), m = p.length();
    int mod = (int) 1e9 + 7, base = 1337;

    long hashP = 0;
    for (int i = 0; i < m; i++) {
        char c = p.charAt(i);
        hashP = (hashP * base + c) % mod;
    }
    // extra 表示 base^(m-1)
    long hashS = 0, extra = 1;
    for (int i = 0; i < n && i < m - 1; i++) {
        hashS = (hashS * base + s.charAt(i)) % mod;
        extra = (extra * base) % mod;
    }
    for (int i = m - 1; i < n; i++) {
        // 当前 hashS 记录了 len(p) 长度的 hash 值
        hashS = (hashS * base + s.charAt(i)) % mod;
        if (hashS == hashP) {
            return i - m + 1;
        }
        // 类似滑动窗口，hashS 只记录 len(p) 长度的 hash，所以要删掉最前面的那个
        hashS = (hashS - extra * s.charAt(i - m + 1)) % mod;
        // 防止负数
        hashS = (hashS + mod) % mod;
    }
    return -1;
}
```


> **注意**：若进行 $n$ 次比较，每次错误率 $\cfrac 1 M$，那么总错误率是 $ 1 - (1 - \cfrac {1} {M}) ^n $。在随机数据下，若 $M = 10^9 + 7$，$ n = 10^6$，错误率约为 $\cfrac 1 {1000}$，并不是能够完全忽略不计的。
>
> 所以，进行字符串哈希时，经常会对两个大质数分别取模，这样的话哈希函数的值域就能扩大到两者之积，错误率就非常小了。
>
> ——摘自 OI-Wiki



### 凸包算法（Andrew 算法）

从图中的最左下角点出发，到最右上角点，如果从某条边出发到下一个点是【左拐】的，就有可能是【外围】，如果是【右拐】的，就不可能是【外围】。而【左拐】和【右拐】的数学表示为向量叉乘。

记当前点为 R，上一个点为 Q，上上个点为 P，则要判断 QR 是否是 PQ【左拐】得到的，要计算 $ cross = \overrightarrow{PQ} \times \overrightarrow{QR}$ 的值，若 $cross < 0$，说明夹角大于 180°，即 R 在 PQ 右边。反之，若 $cross > 0$，R 在 PQ 左边。 

除此之外，需要一个栈 stack 来记录点，因为排好序的原因，对于点 i，必须要满足从 0 到 i 围成的边能把 0~i 全部包围起来（包括边上的点），所以要利用栈将不符合情况的边依次弹出。

从左往右升序遍历只能求出下凸包的边，上凸包的边需要从右往左降序遍历，条件基本一样。需要注意的是起点即终点，从右往左遍历也要考虑起始点。

```java
    int[][] convexHull(int[][] trees) {
        int n = trees.length;
        Arrays.sort(trees, (o1, o2) -> o1[0] - o2[0] == 0 ? o1[1] - o2[1] : o1[0] - o2[0]);
        boolean[] used = new boolean[n];
        int[] stk = new int[n + 1];
        int p = 0;
        for (int i = 0; i < n; i++) {
            while (p >= 2 && cross(trees[stk[p - 2]], trees[stk[p - 1]], trees[i]) < 0) {
                used[stk[--p]] = false;
            }
            stk[p++] = i;
            used[i] = true;
        }
        used[0] = false;
        int tp = p;
        for (int i = n - 1; i >= 0; i--) {
            if (used[i]) continue;
            while (p > tp && cross(trees[stk[p - 2]], trees[stk[p - 1]], trees[i]) < 0) {
                used[stk[--p]] = false;
            }
            stk[p++] = i;
            used[i] = true;
        }
        // 最后组成外围的点即 stk[:-1]
        int[][] res = new int[p - 1][];
        for (int i = 0; i < res.length; i++) {
            res[i] = trees[stk[i]];
        }
        return res;
    }   

    int[] sub(int[] a, int[] b) {
        return new int[]{b[0] - a[0], b[1] - a[1]};
    }

    int cross(int[] a, int[] b, int[] c) {
        // 计算向量 ab x bc 的值
        int[] ab = sub(a, b), bc = sub(b, c);
        return ab[0] * bc[1] - ab[1] * bc[0];
    }

```



```ts
function outerTrees(trees: number[][]): number[][] {
  // 凸包算法 Andrew 算法
  const n = trees.length
  // 按照 x 由小到大、y 由小到大排序
  trees.sort((a, b) => a[0] - b[0] === 0 ? a[1] - b[1] : a[0] - b[0])
  const hull = []; const used = new Array(n).fill(false)
  // 先从左到右遍历，得到下凸包
  for (let i = 0; i < n; i++) {
    // 设栈顶两点组成的向量为 pq，当前点为 r，组成向量为 qr
    // 有 pq x qr < 0 时，r 在 pq 右侧
    while (hull.length >= 2 && cross(sub(trees[hull[hull.length - 2]], trees[hull[hull.length - 1]]), sub(trees[hull[hull.length - 1]], trees[i])) < 0)
      used[hull.pop()] = false

    used[i] = true
    hull.push(i)
  }
  // 不设 used 标记，这样计算上凸包时可以闭合
  used[0] = false
  const size = hull.length
  // 再从右到左遍历，得到上凸包
  for (let i = n - 1; i >= 0; i--) {
    if (used[i])
      continue
    while (hull.length > size && cross(sub(trees[hull[hull.length - 2]], trees[hull[hull.length - 1]]), sub(trees[hull[hull.length - 1]], trees[i])) < 0)
      used[hull.pop()] = false

    used[i] = true
    hull.push(i)
  }
  return hull.map(idx => trees[idx]).slice(0, -1)

}

/**
 * 由 a、b 得到向量 ab
 */
function sub(a: number[], b: number[]): number[] {
  return [b[0] - a[0], b[1] - a[1]]
}

/**
 * 计算向量 a 和向量 b 的叉乘
 */
function cross(a: number[], b: number[]): number {
  return a[0] * b[1] - a[1] * b[0]
}
```



[587. 安装栅栏](https://leetcode-cn.com/problems/erect-the-fence/)



# 工具

### I/O

```java
import java.io.*;

...() throws IOException

BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));

reader.readLine();	// 读一行
reader.close();

writer.write("");	// 写
writer.flush();		// 把缓冲区的字符刷新到屏幕
writer.close(); 	// 关闭
```





# 动态规划分类

**将数组划分为 k 个区间，使【区间和】最小。**

- [1335. 工作计划的最低难度](https://leetcode-cn.com/problems/minimum-difficulty-of-a-job-schedule/)
- [1959. K 次调整数组大小浪费的最小总空间](https://leetcode-cn.com/problems/minimum-total-space-wasted-with-k-resizing-operations/)

**背包问题**

- 01背包
- 完全背包

> 如何界定 01 背包还是完全背包
>
> 看触及的次数，次数少的放外循环，次数多的放内循环。
>
> 如：01 背包，每个物品最多只能选择一次，故物品的遍历放在外循环，背包的容量放在内循环。而完全背包，每个物品能选择多次，那么物品遍历放内循环，背包容量遍历放外循环。

**状态压缩DP**

状态 DP 一般用来解决子集遍历的问题。

> 通过状态压缩，将一个状态压缩成一个 Int32 数字，通过每一位不同的 0/1 区分各状态（如 1 表示第 i 个下标已使用，0 表示未使用）
>
> **枚举一个状态的所有子集**
>
> ```java
> // 设状态为 s
> for (int i = s; i != 0; i = (i - 1) & s) {...}
> ```
>
> 

**数位DP**

- [6151. 统计特殊整数](https://leetcode.cn/problems/count-special-integers/) && [1012. 至少有 1 位重复的数字](https://leetcode.cn/problems/numbers-with-repeated-digits/)

```java
    
int f(int i, int mask, boolean isLimit, boolean isNum) {
        if (i == s.length) return isNum ? 1 : 0;
        if (!isLimit && isNum && dp[i][mask] >= 0) return dp[i][mask];
        var res = 0;
        if (!isNum) res = f(i + 1, mask, false, false); // 可以跳过当前数位
        for (int d = isNum ? 0 : 1, up = isLimit ? s[i] - '0' : 9; d <= up; ++d) // 枚举要填入的数字 d
            if ((mask >> d & 1) == 0) // d 不在 mask 中
                res += f(i + 1, mask | (1 << d), isLimit && d == up, true);
        if (!isLimit && isNum) dp[i][mask] = res;
        return res;
    }

作者：endlesscheng
链接：https://leetcode.cn/problems/numbers-with-repeated-digits/solution/by-endlesscheng-c5vg/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

